extends Node
class_name TrafficSystem
## Tracks road usage and calculates traffic congestion

var grid_system = null

# Default road capacity (vehicles per road tile per month)
const DEFAULT_ROAD_CAPACITY: int = 100

# Traffic map: {Vector2i: traffic_volume}
var traffic_map: Dictionary = {}

# Road capacity map: {Vector2i: capacity}
var road_capacity_map: Dictionary = {}

# Noise pollution map from roads: {Vector2i: noise_level}
var road_noise_map: Dictionary = {}

# Transit coverage map: {Vector2i: reduction_factor}
var transit_coverage: Dictionary = {}

# Transit buildings
var transit_buildings: Array[Node2D] = []

# Transit effectiveness by type
const TRANSIT_EFFECTIVENESS: Dictionary = {
	"bus_stop": 0.15,      # 15% traffic reduction
	"bus_depot": 0.25,     # 25% traffic reduction (larger area)
	"subway_station": 0.40, # 40% traffic reduction
	"rail_station": 0.35,   # 35% traffic reduction
	"airport": 0.10,        # 10% reduction (mostly freight/long distance)
	"seaport": 0.10         # 10% reduction (mostly freight)
}

# Congestion thresholds
const LIGHT_TRAFFIC: float = 0.5
const HEAVY_TRAFFIC: float = 0.8


func _ready() -> void:
	Events.building_placed.connect(_on_building_changed)
	Events.building_removed.connect(_on_building_changed)


func set_grid_system(system) -> void:
	grid_system = system


func _on_building_changed(_cell: Vector2i, building: Node2D) -> void:
	# Track transit buildings
	if building and building.building_data:
		if building.building_data.service_type == "transit":
			if not transit_buildings.has(building):
				transit_buildings.append(building)

	# Clean up invalid transit buildings
	transit_buildings = transit_buildings.filter(func(b): return is_instance_valid(b))

	# Update road capacity map and noise map
	_update_road_infrastructure()

	# Recalculate transit coverage and traffic
	_update_transit_coverage()
	update_traffic()


func _update_road_infrastructure() -> void:
	road_capacity_map.clear()
	road_noise_map.clear()

	if not grid_system:
		return

	# Build road capacity and noise maps from all road-type buildings
	var road_types = ["road", "collector", "arterial", "highway"]
	var counted = {}

	for cell in grid_system.buildings:
		var building = grid_system.buildings[cell]
		if not is_instance_valid(building) or counted.has(building):
			continue
		counted[building] = true

		if not building.building_data:
			continue

		if building.building_data.building_type in road_types:
			# Set road capacity
			var capacity = building.building_data.road_capacity if building.building_data.get("road_capacity") else DEFAULT_ROAD_CAPACITY
			road_capacity_map[cell] = capacity

			# Add noise pollution from roads
			var noise_radius = building.building_data.noise_radius if building.building_data.get("noise_radius") else 0
			if noise_radius > 0:
				_add_road_noise(cell, noise_radius)


func _add_road_noise(center: Vector2i, radius: int) -> void:
	for x in range(-radius, radius + 1):
		for y in range(-radius, radius + 1):
			var distance = sqrt(x * x + y * y)
			if distance <= radius:
				var cell = center + Vector2i(x, y)
				# Noise decreases with distance
				var noise = 0.3 * (1.0 - (distance / float(radius)))
				if road_noise_map.has(cell):
					road_noise_map[cell] = min(1.0, road_noise_map[cell] + noise)
				else:
					road_noise_map[cell] = noise


func _update_transit_coverage() -> void:
	transit_coverage.clear()

	for transit in transit_buildings:
		if not is_instance_valid(transit) or not transit.building_data:
			continue

		# Only operational transit reduces traffic
		if not transit.is_operational:
			continue

		var data = transit.building_data
		var center = transit.grid_cell
		var radius = data.coverage_radius
		var effectiveness = TRANSIT_EFFECTIVENESS.get(data.building_type, 0.1)

		# Add transit coverage in circular area with falloff
		for x in range(-radius, radius + 1):
			for y in range(-radius, radius + 1):
				var distance = sqrt(x * x + y * y)
				if distance <= radius:
					var cell = center + Vector2i(x, y)
					# Coverage strength decreases with distance
					var strength = effectiveness * (1.0 - (distance / float(radius)) * 0.5)

					# Accumulate coverage from multiple transit sources (cap at 70%)
					if transit_coverage.has(cell):
						transit_coverage[cell] = min(0.7, transit_coverage[cell] + strength)
					else:
						transit_coverage[cell] = strength


func update_traffic() -> void:
	traffic_map.clear()

	if not grid_system:
		return

	# Traffic is generated by:
	# - Residential zones (commuters going to work)
	# - Commercial zones (customers and workers)
	# - Industrial zones (freight and workers)

	var counted = {}
	for cell in grid_system.buildings:
		var building = grid_system.buildings[cell]
		if not is_instance_valid(building) or counted.has(building):
			continue
		counted[building] = true

		if not building.building_data:
			continue

		var data = building.building_data
		var traffic_generated = 0

		# Each zone type generates different traffic
		match data.building_type:
			"residential":
				# Residents generate commute traffic
				var pop = building.get_effective_capacity() if building.has_method("get_effective_capacity") else data.population_capacity
				traffic_generated = int(pop * 0.5)  # 50% of capacity generates traffic
			"commercial":
				# Commercial gets customer and worker traffic
				var jobs = building.get_effective_jobs() if building.has_method("get_effective_jobs") else data.jobs_provided
				traffic_generated = int(jobs * 2)  # 2x workers as customers come too
			"industrial":
				# Industrial gets freight and worker traffic
				var jobs = building.get_effective_jobs() if building.has_method("get_effective_jobs") else data.jobs_provided
				traffic_generated = int(jobs * 1.5)  # Workers + freight
			"mixed_use":
				# Mixed-use generates MUCH less traffic - people live and work in same place
				# Only generates traffic for external customers and some residents who work elsewhere
				var pop = building.get_effective_capacity() if building.has_method("get_effective_capacity") else data.population_capacity
				var jobs = building.get_effective_jobs() if building.has_method("get_effective_jobs") else data.jobs_provided
				# Assume 70% of residents work in the same zone, only 30% commute out
				var commute_traffic = int(pop * 0.15)  # Much lower than pure residential
				# Customer traffic is also lower due to local residents shopping locally
				var customer_traffic = int(jobs * 0.5)  # Much lower than pure commercial
				traffic_generated = commute_traffic + customer_traffic

		# Apply transit reduction if building has transit coverage
		if traffic_generated > 0:
			var transit_reduction = transit_coverage.get(building.grid_cell, 0.0)
			traffic_generated = int(traffic_generated * (1.0 - transit_reduction))

		if traffic_generated > 0 and building.is_operational:
			_distribute_traffic(building.grid_cell, traffic_generated, data.size)


func _distribute_traffic(origin: Vector2i, amount: int, building_size: Vector2i) -> void:
	# Find nearby roads and distribute traffic to them
	var nearby_roads: Array[Vector2i] = []

	# Check perimeter of building for roads
	for x in range(-1, building_size.x + 1):
		for y in range(-1, building_size.y + 1):
			if x >= 0 and x < building_size.x and y >= 0 and y < building_size.y:
				continue  # Skip interior

			var check_cell = origin + Vector2i(x, y)
			if grid_system.has_road_at(check_cell):
				nearby_roads.append(check_cell)

	if nearby_roads.size() == 0:
		return

	# Distribute traffic evenly to nearby roads
	var per_road: int = int(amount / float(nearby_roads.size()))
	for road_cell in nearby_roads:
		if traffic_map.has(road_cell):
			traffic_map[road_cell] += per_road
		else:
			traffic_map[road_cell] = per_road

		# Spread traffic along connected roads (simplified)
		_spread_traffic_along_road(road_cell, int(per_road * 0.5))


func _spread_traffic_along_road(start: Vector2i, amount: int) -> void:
	# Simple spread - add reduced traffic to adjacent roads
	var neighbors = [
		start + Vector2i(1, 0),
		start + Vector2i(-1, 0),
		start + Vector2i(0, 1),
		start + Vector2i(0, -1)
	]

	var spread_amount: int = int(amount * 0.25)
	for neighbor in neighbors:
		if grid_system.has_road_at(neighbor):
			if traffic_map.has(neighbor):
				traffic_map[neighbor] += spread_amount
			else:
				traffic_map[neighbor] = spread_amount


func get_traffic_at(cell: Vector2i) -> int:
	return traffic_map.get(cell, 0)


func get_congestion_at(cell: Vector2i) -> float:
	var traffic = get_traffic_at(cell)
	var capacity = road_capacity_map.get(cell, DEFAULT_ROAD_CAPACITY)
	return min(1.0, float(traffic) / float(capacity))


func is_congested(cell: Vector2i) -> bool:
	return get_congestion_at(cell) > HEAVY_TRAFFIC


func get_average_congestion() -> float:
	if traffic_map.size() == 0:
		return 0.0

	var total_congestion = 0.0
	for cell in traffic_map:
		total_congestion += get_congestion_at(cell)

	return total_congestion / traffic_map.size()


func get_city_traffic_score() -> float:
	# Returns 0-1 where 1 = no traffic, 0 = gridlock
	var avg_congestion = get_average_congestion()
	return 1.0 - avg_congestion


func get_congested_road_count() -> int:
	var count = 0
	for cell in traffic_map:
		if is_congested(cell):
			count += 1
	return count


func get_traffic_map() -> Dictionary:
	return traffic_map


func get_transit_coverage_at(cell: Vector2i) -> float:
	return transit_coverage.get(cell, 0.0)


func has_transit_coverage(cell: Vector2i) -> bool:
	return transit_coverage.get(cell, 0.0) > 0.1


func get_transit_coverage_map() -> Dictionary:
	return transit_coverage


func get_city_transit_coverage() -> float:
	# Returns percentage of developed cells with transit access
	if not grid_system:
		return 0.0

	var covered_count = 0
	var total_count = 0
	var counted = {}

	for cell in grid_system.buildings:
		var building = grid_system.buildings[cell]
		if not is_instance_valid(building) or counted.has(building):
			continue
		counted[building] = true

		if building.building_data and building.building_data.category == "zone":
			total_count += 1
			if has_transit_coverage(cell):
				covered_count += 1

	if total_count == 0:
		return 0.0

	return float(covered_count) / float(total_count)


# ============================================
# ROAD NOISE SYSTEM
# ============================================

func get_road_noise_at(cell: Vector2i) -> float:
	return road_noise_map.get(cell, 0.0)


func get_road_noise_map() -> Dictionary:
	return road_noise_map


func get_road_capacity_at(cell: Vector2i) -> int:
	return road_capacity_map.get(cell, DEFAULT_ROAD_CAPACITY)


func get_residential_noise_penalty() -> float:
	# Calculate total happiness penalty from road noise affecting residential zones
	if not grid_system:
		return 0.0

	var total_penalty = 0.0
	var counted = {}

	for cell in grid_system.buildings:
		var building = grid_system.buildings[cell]
		if not is_instance_valid(building) or counted.has(building):
			continue
		counted[building] = true

		if not building.building_data:
			continue

		# Only residential zones are affected by road noise
		if building.building_data.building_type in ["residential", "mixed_use"]:
			var noise = get_road_noise_at(building.grid_cell)
			if noise > 0.1:
				# Noise above 10% starts affecting happiness
				total_penalty += (noise - 0.1) * 0.05  # Up to 4.5% per affected zone

	return min(0.15, total_penalty)  # Cap at 15% total penalty
